# フロントエンドロードマップ

## 概要

各セクションの項目を実際にコードに書き起こし、
説明はプルリクで実施。
LGTM をもらい次第完了とする。<br>
同時に項目を完了できるように、プルリク時は項目番号を記載してプルリクを出す。<br>
(例)HTML-1,HTML2 の完了<br>
HTML-1 の説明<br>
HTML-２の説明

## 環境

yarn dev

## HTML

- [ ] HTML-1「HTML の文書メタデータ要素について理解し、説明できる。」
- [ ] HTML-2「HTML のコンテンツ区分要素について理解し、説明できる。」
- [ ] HTML-3「HTML のテキストコンテンツ要素について理解し、説明できる。」
- [ ] HTML-4「HTML のインラインテキスト意味付け要素について理解し、説明できる。」
- [ ] HTML-5「HTML のマルチメディア要素について理解し、説明できる。」
- [ ] HTML-6「HTML のテーブル要素について理解し、説明できる。」
- [ ] HTML-7「HTML のフォーム要素について理解し、説明できる。」
- [ ] HTML-8「上記以外の HTML 要素の区分を把握している。（調べても OK）」
- [ ] HTML-9「"ブロックレベル要素について理解し、説明できる。」  
      「ブロックレベル要素に該当する要素を把握している。（後者は調べても OK）"」
- [ ] HTML-10「"インライン要素について理解し、説明できる。」<br/>
      「インライン要素に該当する要素を把握している。（後者は調べても OK）"」
- [ ] HTML-11「"head 要素の使用用途を理解し、説明できる。」<br/>
      「head 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-12「"title 要素の使用用途を理解し、説明できる。」<br/>
      「title 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-13「"meta 要素の使用用途を理解し、説明できる。」<br/>
      「meta 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-14「"article 要素の使用用途を理解し、説明できる。」<br/>
      「article 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-15「"header 要素の使用用途を理解し、説明できる。」<br/>
      header 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-16「"footer 要素の使用用途を理解し、説明できる。」<br/>
      「footer 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-17「"main 要素の使用用途を理解し、説明できる。」<br/>
      「main 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-18「"section 要素の使用用途を理解し、説明できる。」<br/> -「section 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-19「"h1–h6 要素の使用用途を理解し、説明できる。」<br/>
      「h1–h6 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-20「"nav 要素を使用用途を理解し、説明できる。」<br/>
      「nav 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-21「"div 要素を使用用途を理解し、説明できる。」<br/>
      「div 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-22「"p,pre 要素を使用用途を理解し、説明できる。」<br/>
      「p,pre 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-23「"ol,ul,menu,li 要素を使用用途を理解し、説明できる。」<br/>
      「ol,ul,menu,li 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-24「"figure,figcaption 要素を使用用途を理解し、説明できる。」<br/>
      「figure,figcaption 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-25「"hr 要素を使用用途を理解し、説明できる。」<br/>
      「hr 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-26「"a 要素を使用用途を理解し、説明できる。」<br/>
      「a 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-27「"br 要素を使用用途を理解し、説明できる。」<br/>
      「br 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-28「"span 要素を使用用途を理解し、説明できる。」<br/>
      「span 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-29「"img 要素を使用用途を理解し、説明できる。」<br/>
      「img 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-30「"audio 要素を使用用途を理解し、説明できる。」<br/>
      「audio 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-31「"video 要素を使用用途を理解し、説明できる。」<br/>
      「video 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-32「"track 要素を使用用途を理解し、説明できる。」<br/>
      「track 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-33「"iframe 要素を使用用途を理解し、説明できる。」<br/>
      「iframe 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-34「"form 要素を使用用途を理解し、説明できる。」<br/>
      「form 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-35「"label 要素を使用用途を理解し、説明できる。」<br/>
      「label 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-36「"input 要素を使用用途を理解し、説明できる。」<br/>
      「input 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-37「"textarea 要素を使用用途を理解し、説明できる。」<br/>
      「textarea 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-38「"select,option 要素を使用用途を理解し、説明できる。」<br/>
      「select,option 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-39「"button 要素を使用用途を理解し、説明できる。」<br/>
      button 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-40「"テーブル要素（table, th, td など）を使用用途を理解し、説明できる。」<br/>
      「テーブル要素（table, th, td など）の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-41「"svg 要素を使用用途を理解し、説明できる。」<br/>
      「svg 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-42「"dialog 要素を使用用途を理解し、説明できる。」<br>
      「dialog 要素の持つ属性を把握し、使うことができる。（後者は調べても OK）"」
- [ ] HTML-43「上記以外の要素の存在を把握している。（調べても OK）」
- [ ] HTML-44「非推奨なタグの存在を把握している。（調べても OK）」
- [ ] HTML-45「"グローバル属性について理解し、説明できる。」<br/>
      「グローバル属性を把握している。（後者は調べても OK）"」
- [ ] HTML-46「"イベントハンドラー属性について理解し、説明できる。」<br/>
      「イベントハンドラー属性を把握している。（後者は調べても OK）"」
- [ ] HTML-47「MDN の「アクセシビリティとは？」を読む。」
- [ ] HTML-48「WAI-ARIA について大まかに理解し、説明できる。」
- [ ] HTML-49「"WAI-ARIA 属性について理解し、説明できる。」<br/>
      「WAI-ARIA 属性を把握している。（後者は調べても OK）"」

### 最低ライン

#### タグの要素をある程度理解し、使いこなせるようにする

- メタデータ系+スクリプト
  - html, head, body, link, meta, style, title, script
- セクショニング
  - header, footer, main, nav, article, section, aside, h1~6
  - なぜ div ではなくこれらを使う必要があるのか知る
- テキストコンテンツ
  - div, hr, ul, li, p
- インライン
  - a, br, span, small
- マルチメディア
  - img, video
- 埋め込みコンテンツ
  - iframe, picture, source
- テーブル
  - table, thead, tbody, tfoot, col, tr, th, td
- フォーム
  - form, button, label, input, textarea, select, option

#### タグの属性を理解する

- グローバル属性
  - id, class, style, data-\*, hidden,
- タグ固有の属性
  - a タグに href があるように、固有の属性があることを知る。
  - 勝手に覚えていくので無理して暗記する必要はない。

## CSS

- [ ] CSS-1「CSS の基本セレクターの使用用途を理解し、説明できる。」
- [ ] CSS-2「CSS のグループ化セレクターの使用用途を理解し、説明できる。」
- [ ] CSS-3「"CSS の結合子の使用用途を理解し、説明できる。」<br>
      「CSS の結合子（全 5 種類）を把握している。"」
- [ ] CSS-4「CSS の擬似クラスの使用用途を理解し、説明できる。」
- [ ] CSS-5「CSS の擬似要素の使用用途を理解し、説明できる。」
- [ ] CSS-6「CSS アットルール、＠media の使用用途を理解し、説明できる。」
- [ ] CSS-7「CSS の詳細度について理解し、説明できる。」
- [ ] CSS-8「CSS の継承プロパティについて理解し、いくつかプロパティ名を把握している。」
- [ ] CSS-9「CSS の非継承プロパティについて理解し、いくつかプロパティ名を把握している。」
- [ ] CSS-10「CSS のプロパティを明示的に継承・初期化することができる。」
- [ ] CSS-11「一括指定プロパティ（background, font, border, margin, padding）の省略記法を理解し、使うことができる。」
- [ ] CSS-12「CSS の関数記法について理解・把握し、使うことができる。（把握については調べても OK）」
- [ ] CSS-13「CSS のボックスモデル（ブロックボックス、インラインボックス）について理解し、説明できる。」
- [ ] CSS-14「CSS の絶対長単位について理解・把握し、使うことができる。（把握については調べても OK）」
- [ ] CSS-15「CSS の相対長単位について理解・把握し、使うことができる。（把握については調べても OK）」
- [ ] CSS-16「CSS レイアウト Flexbox について理解し、説明できる。」
- [ ] CSS-17「CSS レイアウト Grid について理解し、説明できる。」
- [ ] CSS-18「CSS のレンダリングステップ（レイアウト、ペイント、コンポジット）を理解し、説明できる。」
- [ ] CSS-19「セレクタによって CSS のパフォーマンスに違いがあることを理解し、説明できる。」
- [ ] CSS-20「"CSS のパフォーマンスに高負荷を与える CSS のプロパティがあることを理解・把握し、説明することができる。」
- [ ] CSS-21「（把握については調べても OK）"」
- [ ] CSS-22「空の div 要素や br 要素、スタイルを持つ要素（i 要素や strong 要素など）を使わずにスタイリングできる。」
- [ ] CSS-23「CSS の設計手法（BEM、FLOCSS、OOCSS など）を複数把握していて、その良し悪しを説明できる。」
- [ ] CSS-24「BEM について大まかに理解し、説明できる。」
- [ ] CSS-25「OOCSS について大まかに理解し、説明できる。」
- [ ] CSS-26「SMACSS について大まかに理解し、説明できる。」
- [ ] CSS-27「PRECSS について大まかに理解し、説明できる。」

### 最低ライン

#### プロパティとそれぞれの取りうる値を知る

取りうる値は必要になったものを自然と覚えていくので暗記する必要はない。

- レイアウト
  - display, (max,min)width, (max,min)height, margin, padding, border, outline
- フォント
  - font-weight, font-size, font-family
- テキスト
  - line-height, text-align, vertical-align, text-decoration, white-space, letter-spacing, word-break, text-shadow
- 文字色・背景
  - color, background-color, background-image, background-position, background-repeat,
    background-size, opacity
- 表示・配置
  - overflow, position, display, z-index, visibility
- フレックス
  - flex, flex-direction, justify-content, align-items, align-self
  - 特に重要で Flexbox でレイアウトを組み立てられるようになる必要がある
- その他
  - box-sizing, list-style, cursor, object-fit, object-position

#### セレクタについて知る

- 基本
  - タイプセレクター(div, span など)
  - クラスセレクター(.classname)
  - ID セレクター(#idname)
  - ユニバーサルセレクター(\*)
- 属性セレクター
  - [attr], [attr=value], [attr~=value], [attr|=value], [attr^=value], [attr$=value], [attr*=value]
- 部分文字列一致セレクター
- 擬似表記
  - 擬似クラス
    - :hover, :not, :nth-child, :nth-of-type
  - 擬似要素
    - ::after, ::before
- 結合子
  - 子孫結合子(A B)
  - 子結合子(A > B)
  - 隣接兄弟結合子(A + B)
  - 一般兄弟結合子(A ~ B)

#### ボックスモデルの理解

- width, height, padding, margin, border の理解
- インライン・ブロック違いを知る
  - 改行されるかどうか
  - width, height の挙動
  - padding, margin, border の挙動
- box-sizing プロパティについて知る
  - なぜ全要素に border-box を適用させるのか

#### カスケード・詳細度・継承

- カスケードとは何か概要を掴む
- 詳細度のスコアリングについて学ぶ
- 継承とはどういうものか学ぶ
- !important をあまり使ってはいけない理由を知る

#### レスポンシブ

- viewport を理解する
- メディアクエリを理解する
  - メディアタイプとは何か学ぶ
  - メディア特性について学ぶ
- モバイルファーストで書けるようにする

## HTML・CSS 実践

### 最低ライン

#### Chrome DevTools の「Elements」タブを使えるようにする

- 要素を選択し、削除したり、コピーができる
- 「Styles」で CSS プロパティを変更しながら見た目の調整ができる

#### よくあるレイアウトを作れるようになる

- 聖杯レイアウト
- サイドバーレイアウト
- タブメニュー
- ハンバーガー（ドロワー）メニュー
- ボトムナビゲーション
- モーダル（ポップアップ）

#### 実際に書く

- 複数のサイトを参考に、実際にソックリな見た目を作れるようになる
  - デザイン重視の LP よりも、よく使われる Web アプリケーションを模倣する
  - アニメーションはそこまで使われていないサービスが良い
  - しっかりレスポンシブの見た目まで模倣できるようにする

## JavaScript

- [ ] JS-1「ECMAScript 標準の 8 つの型を把握、説明できる。」
- [ ] JS-2「"プリミティブ（String、Number、Boolean など）操作ができる。」<br>
      「プリミティブなオブジェクトが持つ、メソッド（関数）を把握し、使うことができる。（後者は調べても OK）"」
- [ ] JS-3「"コレクション（Object、Array、Tuple など）操作ができる。」<br>
      「コレクション系のオブジェクトが持つ、メソッド（関数）を把握し、使うことができる。（後者は調べても OK）"」
- [ ] JS-4「"Date オブジェクトの操作ができる。」<br>
      「Date オブジェクトが持つ、メソッド（関数）を把握し、使うことができる。（後者は調べても OK）"」
- [ ] JS-5「関数の宣言方法を複数把握していて、その良し悪しを説明、使い分けることができる。」
- [ ] JS-6「処理の条件分岐方法を複数把握していて、その良し悪しを説明、使い分けることができる。」
- [ ] JS-7「処理のループ方法を複数把握していて、その良し悪しを説明、使い分けることができる。」
- [ ] JS-8「再起処理について理解し、その良し悪しを説明、適切に扱うことができる。」
- [ ] JS-9「高階関数について理解し、その良し悪しを説明、適切に扱うことができる。」
- [ ] JS-10「"文字コード、サロゲートペアについて理解し、説明できる。」<br>
      「文字コード、サロゲートペアなどを考慮して文字列を操作することができる。"」
- [ ] JS-11「JavaScript の等価性（同値性と同一性）について、それぞれの違いを把握していて、説明・使い分けることができる。」
- [ ] JS-12「JavaScript の値のポインタ（参照）について理解し、説明できる。」
- [ ] JS-13「JavaScript の this の振る舞いについて理解し、説明できる。」
- [ ] JS-14「JavaScript のクラスについて理解し、説明できる。」
- [ ] JS-15「JavaScript でオブジェクト指向的な書き方をすることができる。」
- [ ] JS-16「例外処理を実装できる。」
- [ ] JS-17「非同期処理（aync/await、Promise を使ったコード）を実装できる。」
- [ ] JS-18「DOM 操作（document.querySelector など）ができる。」
- [ ] JS-19「ES6 に準拠した記述ができる。（アロー関数、配列のスプレッド構文、Promise などが使える。）」
- [ ] JS-20「ES2016 に準拠した記述ができる。（冪乗演算子、Array.prototype.include などが使える。）」
- [ ] JS-21「ES2017 に準拠した記述ができる。（Object.entries、async/awaitn などが使える。）」
- [ ] JS-22「ES2018 に準拠した記述ができる。（オブジェクトのスプレッド構文、Promise.prototype.finaly などが使える。）」
- [ ] JS-23「ES2019 に準拠した記述ができる。（Array.prototype.flat、Object.fromEntries などが使える。）」
- [ ] JS-24「ES2020 に準拠した記述ができる。(Nullish Coalescing 演算子（??）や Optional Chaining（?）などが使える。)」
- [ ] JS-25「ES2021 に準拠した記述ができる。(String.replaceAll、数値セパレータなどが使える。)」
- [ ] JS-26「ES2022 に準拠した記述ができる。(クラスのプライベートメソッド、Array.at などが使える。)」

### 最低ライン

#### ECMAScript について知る

- ECMAScript は JavaScript の標準仕様
  - どの実行環境でも共通な動作を定義
- JavaScript の「言語」を学ぶときは主に下記 3 つを学ぶことと同義
  1. ECMAScript を学ぶ（基本構文）
  1. ブラウザの環境下で使えるオブジェクトを学ぶ
  1. Node.js の環境下で使えるオブジェクトを学ぶ（Node.js を学ぶのは後々で良い）
- ECMAScript は毎年新機能が追加される
  - その年の新機能は ES + 年号で定義される。ES2021 など
  - 当初は ES1, ES2, ...という命名だったが 2015 年から ES+年号になった
  - ES2015 で言語仕様がガラッと変わり、大きく進化した

#### 基本構文

- let, const（もう var を使うことはない）
- 文字列
  - テンプレートリテラル
  - 文字列結合(+)
  - 分解(split)
  - すべて覚える必要は無いが、length や split など色んなプロパティやメソッドがあることを知る（「どう
    実現するんだろう」ってなって調べて覚える）
- 数値
  - 演算子を使った計算ができるようにする（四則演算、++、--、大小比較など）
  - Math のメソッドで数値を操作できることを知る（数値を整数にするなど）
- 真偽値, undefined, null などのデータ型があることを知る
  - Falsy な値・Truty な値とは何かを知る
  - 条件分岐で実行される条件、されない条件の書き方をある程度知る（&&, ||, !, <=, ===などの論理演算子
    や比較演算子）
- 条件分岐
  - if, else, else if
  - switch, break
  - 三項演算子を用いた条件分岐を学ぶ
- 配列
  - 配列に追加したり、削除したり、アクセスするための方法を知る
  - 色んな繰り返し処理がある
    - forEach, map, filter は絶対に使えるようにする
    - 上記以外の例えば find, some, every などは必要になってから調べるでいい
  - 他にもすべて覚える必要は無いが、length や slice, includes など色んなプロパティやメソッドがあるこ
    とを知る（「どう実現するんだろう」ってなって調べて覚える）
- オブジェクト
  - 作成方法や、キー、値などの基本を学ぶ
  - ドット記法とブラケット記法でアクセスできる
    - 基本的にはドット記法、どうしても書けない場合はブラケット記法を使う
  - プロパティの追加や削除ができるようにする
- 配列とオブジェクト
  - 配列とオブジェクト、それぞれの分割代入の書き方を学ぶ
    - React などでもよく使われる書き方のため
  - ミュータブル・イミュータブルとは何か知る
    - 破壊的なメソッドはなるべく使わない
    - 非破壊的なメソッドで実現するように心がける
    - 例えば sort は破壊的なメソッドだが、スプレッド構文と組み合わせて非破壊的に使うことができる
      - スプレッド構文を使えるようにする
- 関数
  - 基本的な使い方を学ぶ
    - 関数宣言の書き方を学ぶ（function）
  - 引数について学ぶ
    - デフォルト引数を使えるようにする
    - Rest parameters の使えるようにする
    - 分割代入を使えるようにする
  - 関数式の書き方を学ぶ
  - アロー関数の書き方を学ぶ
    - 基本はアロー関数を使う
    - 現場では関数宣言で書かれることも多いことだけ注意
  - コールバック関数について学ぶ

#### ブラウザの環境下で使えるオブジェクト

- Window オブジェクト
  - すべて覚える必要は無いが、console や alert, localStorage など色んなプロパティやメソッドがあること
    を知る（必要になってから調べて覚えるで OK）
- DOM
  - DOM とは何かを知る
    - HTML と似ているけど違う
    - HTML のコンテンツを JavaScript から操作できるオブジェクト
    - HTML 要素を取得したり、新しく HTML 要素を作成するメソッドがある
  - すべて覚える必要は無いが、location や querySelector, createElement など色んなプロパティやメソッ
    ドがあることを知る（必要になってから調べて覚えるで OK）
  - イベントを設定できる
    - click 時、ローディング時など色んなタイミングでイベントを起動させられる
    - addEventListener の使い方を知る（コールバック関数について把握している必要あり）

#### 非同期処理

- fetch も Window オブジェクトのメソッドの 1 つ
- 同期処理・非同期処理について知る
  - どういうときに使うのか
  - 普通に書いたらすべて同期処理
  - 非同期処理は実現方法がいくつかあるが、今は async await を用いるのが一般的。
- サーバーからデータ取得をする API
  - API という言葉は幅広く、色んなものがある
  - その中でもサーバーからデータ取得をするための API について学んでほしい
  - 基本は API を叩いて（API 経由でデータを取得して）、そのデータをブラウザで表示する
    - ザックリだが、バックエンドの仕事は API をつくること
    - フロントエンドの仕事は API を叩いてユーザーに見せること
  - 実際に API を叩いてみよう
    - 最初から自分で API を作るのは難しいのでオープンに公開されている API を叩く
    - 例えば、 https://jsonplaceholder.typicode.com など。
    - API を叩いて、そこから得られたデータを DOM を操作して、画面に表示できるようにする

## HTML・CSS・JavaScript を通しての所感

HTML・CSS・JavaScript はここらへんまで理解できたら OK だと考えている。あとは実践で必要になってググりながら学ぶので間に合う。

よく HTML や CSS の細かいところまで覚えたり、JavaScript だと DOM の色んなメソッドを覚える人がいるが、現代のフロントエンド開発において素の HTML や CSS、JavaScript を使うことは少なくなっているため、正直そういった細かい知識は使われないことが多い。

例えば React だと HTML の代わりに JSX という記法で表現したり、CSS は CSS フレームワークや CSS in JS などで管理する。また React や Vue、Angular には仮想 DOM という概念があり、開発者は基本的に仮想 DOM を触り、ブラウザが標準で用意している DOM を扱うことはほとんど無い。appendChild とか textContent とか全くと言っていいほど使わない。

大事なのは概念理解、HTML や CSS、JavaScript で何ができるのか、なぜ必要なのかを理解することである。JavaScript は色々できるが、基本的な仕事は「データのやり取りをすること」「（仮想）DOM を扱うこと」の 2 つと思っていただいて良い。基本構文・ブラウザの環境下で使えるオブェクト・非同期処理さえ、概ねの理解できたらサッと次に進もう。

また jQuery や Bootstrap は学ぶ必要ないです。現場で使われてたらそのときに覚えるで OK です。

## その他

- [ ] Ex-1「SPA について理解し、説明できる。」
- [ ] Ex-2「SSR について理解し、説明できる。」
- [ ] Ex-3「SSG について理解し、説明できる。」
- [ ] Ex-4「SPA, SSR, SSG の違いを理解し、その良し悪しを説明できる。」
- [ ] Ex-5「SOLID の原則について大まかに理解し、説明できる。」
- [ ] Ex-6「オブジェクト指向について大まかに理解し、説明できる。」
- [ ] Ex-7「コンポーネント指向について大まかに理解し、説明できる。」
- [ ] Ex-8「関数型プログラミングについて大まかに理解し、説明できる。」
- [ ] Ex-9「オブジェクト指向プログラミングについて大まかに理解し、説明できる。」
- [ ] Ex-10「コンポーネント指向プログラミングについて大まかに理解し、説明できる。」
- [ ] Ex-11「Web ブラウザへのアクセスの仕組みを理解し、説明できる。」
- [ ] Ex-12「IP アドレスについて大まかに理解し、説明できる。」
- [ ] Ex-13「DNS について大まかに理解し、説明できる。」
- [ ] Ex-14「HHTP について大まかに理解し、説明できる。」
- [ ] Ex-15「SSH について大まかに理解し、説明できる。」
- [ ] Ex-16「HTTP と HTTPS の違いを理解し、説明できる。」
- [ ] Ex-17「Web ブラウザを複数把握していて、その違いを簡単に説明できる。」
- [ ] Ex-18「レンダリングエンジンを複数把握していて、その違い、どの Web ブラウザに使われているかを簡単に説明できる。」
- [ ] Ex-19「レンダリングエンジンの仕組みを大まかに理解し、簡単に説明できる。」
- [ ] Ex-20「JavaScript エンジンを複数把握していて、その違い、どの Web ブラウザに使われているかを簡単に説明できる。」
- [ ] Ex-21「JavaScript エンジンの仕組みを大まかに理解し、簡単に説明できる。」
- [ ] Ex-22「REST API について大まかに理解し、簡単に説明できる。」
- [ ] Ex-23「REST API のメソッドを把握していて、その違いを簡単に説明できる。」

## モジュール

### 概要

今まで JavaScript の名前空間は Window の 1 つしかありませんでした。名前空間が 1 つのせいで、変数名や関数名が被ったり、依存のあるコードが多くなって管理できずにバグを生み出していました。それを解決するのがモジュールという概念です。フロントエンド開発をするときにモジュールが無いのはありえない・・・ってぐらい重要です。

### 最低ライン

- モジュールとは何か知る
  - JavaScript におけるモジュールはファイル単位
    - 1 ファイル 1 モジュール
  - モジュールがあると何が嬉しいのか
    - 名前空間問題が解決される（Window 1 つからファイル単位へ）
    - 再利用性が高まる
    - ファイル単位で管理できるので保守性が高い
- 現在はモジュールには大きく 2 種類ある
  1. ES Modules (ESM) 形式
     - ECMAScript 標準なので、今後こちらが主流になる
     - フロントエンド開発を行うときも基本はこっち
     - この書き方はマスターする必要あり
  1. CommonJS (CJS) 形式
     - Node.js で使われてきた方式
     - だんだん ESM 形式に変わっていくと見られている
     - 必要になったタイミングで覚える
- ESM 形式の書き方
  - Named Import
    - 基本はこっちを使う
  - Default Import
  - All Import, Re-export, Side Effect を学ぶ

## CLI（コマンドラインインターフェース）

### 概要

CUI とも言います。エンジニアになるためにはコマンドライン操作は欠かせません。人間がポチポチやるより機械に任せたほうが良い操作はたくさんあります。また後述の npm でも必要になってくるので最低限は覚えましょう。

### 最低ライン

- シェルとは何かを知る
  - （人間の）命令をコンピュータに伝えるプログラム
  - bash, zsh, fish が有名
    - bash がデフォルトだけど zsh か fish が多い印象
    - fish はカスタマイズしなくても良い感じに色んな機能があるのでオススメ（私も使ってます）
- PC のディレクトリ構成を知る
  - OS によっても違いがある
  - root ディレクトリとは何か知る
  - home ディレクトリとは何か知る
  - 絶対パスと相対パスを知る
- 基本的なコマンドに慣れる
  - pwd（パス確認）
  - cd（移動）
  - ls（ディレクトリ内の階層を一覧表示）
  - touch（空のファイルを新規作成やタイムスタンプの操作など）
  - cp（ファイルやディレクトリのコピー）
  - mv（ファイルやディレクトリの移動）
  - rm（ファイルやディレクトリの削除）
  - mkdir（ディレクトリの新規作成）
  - rmdir（ディレクトリの削除）
  - cat（ファイルの内容の確認など）
- コマンドはオプションと一緒に使うことも多い
  - rm -r とすると今いる階層だけでなく下の階層まで処理する
  - オプションは必要になったタイミングでググって覚えるで OK
- コマンドは他にもたくさんあるが、必要に迫られたり、余力があるときに知識を蓄える必要あり
  - npm を学ぶ上ではいったん上記コマンドさえ分かれば問題なさそう

## npm

### 概要

コードを公開したり共有するときにパッケージ管理システム（npm or yarn）が使われます。今のフロントエンドでは自分で機能をイチから作るよりも第三者が公開しているパッケージを利用して作ることの方が多いです。

例えば画像のスライダーも自分で自作するより、既にあるパッケージを利用して実装します（もちろん自作できるぐらいのプログラミングスキルがある方が望ましいですね）。

パッケージを利用するために npm が必要なのでぜひマスターしましょう。

### 最低ライン

- npm と yarn について
  - どちらもパッケージ管理システム
  - yarn が後出で基本的には npm と互換性がある
  - ただしいくつかの点で yarn 推し
    - yarn upgrade-interactive という npm には無い便利コマンドがある
    - 純粋に yarn の方がパフォーマンスが良い
    - yarn の方がセキュアらしいですが、内容までは詳しく知りません
    - monorepo という技術があるのですが、それを使うときに yarn の方が便利（今は無視で OK です）
- npm, yarn のインストール方法
  - npm や yarn は Node.js を用いて動かしているので、Node.js 自体をまずは入れる必要がある。
  - Node.js は Node.js バージョン管理ツールで基本的にインストールする
  - NVM, n などが有名だが、最近出た VOLTA が個人的にオススメです
    - 公式: https://volta.sh/
    - セットアップが楽
    - めちゃくちゃ高速
    - クロスプラットフォーム（Windows でも動く）
    - プロジェクトごとのバージョン管理が楽
  - VOLTA を入れたら、Node.js と一緒に npm もインストールされる
    - あとは npm install -g yarn で yarn もインストールできる
- 基本的な使い方を学ぶ
  - package.json と CLI で管理する手法を学ぶ
    - パッケージのインストール方法や削除方法
      - npm i <パッケージ名>または yarn add <パッケージ名>
      - npm remove <パッケージ名>または yarn remove <パッケージ名>
    - package.json や package-lock.json（yarn だと yarn.lock）の見方を学ぶ
      - バージョンをアップさせるにはどうしたら良いか
      - セマンティックバージョニングを使ったバージョン指定に関するルールを知る
  - グローバルインストールとローカルインストールについて知る
    - なぜグローバルよりローカルインストールが好まれるのか
  - インストールしたパッケージの使い方を知る
    - node_modules 経由で読み込む
  - npm scripts でコマンドを使えるようにする
  - npx について
    - npx が npm や yarn とどう違うのか知る

## Babel

### 概要

ある構文の JavaScript を、別の構文の JavaScript に変換するツール。ES2015（当時は ES6 と呼ばれていた） が出たときに非常に便利な構文がたくさん出たのに、ブラウザの互換性がなかったため、便利な構文を使えなかった。ES6 を旧ブラウザで動くバージョン（ES5）に変換するのを目的として誕生した。そのため最初の名前は Babel ではなく 6to5 という名前だった。

そこから転じて、最新の便利な構文を色んなブラウザで動くように変換するだけではなく、通常だったらブラウザ上で動かないものも動くように変換するためにも使われるようになった。例えば React では JSX という HTML に似た記法でコードを書いていくが、これはブラウザ上では動かすことができない。その JSX をブラウザで動かすためにも用いられる。また最近では TypeScript も Babel を通じて他の変換作業と一緒に JavaScript に変換することが多い。

React や TypeScript を学んでいく上では概念理解は避けては通れないが、正直一から自分で書く必要は無い。というのも Next.js や Create React App でプロジェクトを作る場合が多く、そのときは Babel は隠蔽されてて開発者が意識することはほとんど無いからだ。ただしプロジェクトによっては Babel の設定ファイルを自分で書いたりする必要があるので、急に名前を見ても驚かないようにするために概念だけは抑えておこう。

### 最低ライン

- Babel とは何かを学ぶ
  - 上記説明だけで理解できない場合は公式を見たり、ググったりしながら理解を深める
  - Babel で一度ある JavaScript を、別の JavaScript に変換して感覚を掴んでもらう

Babel は概念理解が重要なのでそれだけで OK です。

## webpack

### 概要

従来 JavaScript にモジュールという機能はなく、Node.js が誕生した際にモジュールの概念が生まれた。Node.js はドンドン進化してモジュールを活用した便利なパッケージが生まれたが、Node.js とブラウザの JavaScript の環境は違うため、Node.js のパッケージをそのままブラウザで使用することができなかった。それをできるようにしているのが webpack。

それが歴史ではあるが、今となっては Node.js のパッケージを使えるようにするだけではなく、色んなものを一緒に変換したり、変換時に便利な機能を追加できるようになった。例えばスタイルシートや画像ファイルも JavaScript 上で扱いやすくするために変換できるし、変換と同時に Tree Shaking（不要なコードの削除）や minify（圧縮）を行ってサイズを減らすことができる。

また webpack のローカル開発環境を立ち上げ＋ホットリロードという機能を用いることで、「コードを書く → 手動で変換 → 確認」という流れから「コードを書く → 自動変換 → 確認」という流れになり、開発が非常に容易になった。

他にも依存関係の解決を行ってくれる。開発者が依存関係を把握しながらコードを書くことは現実的ではないので、webpack を用いて自動的に解決を行う。

・・・という感じで webpack は正直あまりにもできることが多い。概念理解が最も難しく、一気にすべてを理解することは不可能（私もすべて知っているわけではない）なので、最低限必要な部分を覚える必要がある。

こちらも Babel と同じく Next.js や Create React App の存在で設定ファイルを自分で一から記述することは少なくなった。ただしプロジェクトによっては一から設定ファイルを書いているところもあるので、ある程度は概念理解をし、必要になったタイミングですぐにググって設定ファイルを書けるようにする必要がある。

### 最低ライン

- webpack が必要な理由を知る
  - CJS 形式やその他のブラウザで動かないパッケージをブラウザで実行可能にする
  - パッケージ同士の依存関係を自動解決してくれる
  - 画像・フォント・スタイルシートなどを JavaScript で扱えるようにする
  - Tree Shaking（不要なコードの削除）や minify でサイズ圧縮ができる
  - ローカルサーバーを立ち上げ開発環境を作ることができる
  - Babel などと一緒に用いて、最新の ES や TypeScript なども変換できる
  - その他、変換時に何かしたければ何でもできる
- かんたんな例で、webpack を実際に自分の手元で試してみて感覚を掴む

webpack も概念理解が重要なので一旦それだけで OK です。

## ESLint

### 概要

プロジェクトのコードを書いている段階で、問題となるコードを教えてくれたり、書き方のスタイルを統一するために指摘してくれるもの。チーム内で書き方を統一するのは非常に大事で、しっかりと統一することでコードが読みやすくなり運用コストも下がる。

ESLint は「自動修正」や「独自カスタマイズ」もできる。前者の「自動修正」は、エディターで保存したときやコマンドライン上からコードを自動で整形できるというもの。Prettier と被る部分もあり、その話に関しては次の Prettier の項目で触れるのでここでは割愛。

後者の「独自カスタマイズ」は自分でルールを書いて（設定項目を追加して）、好きなように指摘してくれるようにできるというもの。例えば JavaScript には関数宣言（function の構文）やアロー関数があるが、ルール次第で function に統一できたりアロー関数に統一できたりする。ルールを 1 から自分で書くこともできるし、第三者が公開した既にあるルールをベースに進めることも可能だ。

また ESLint はその名の通り、ES（ECMAScript）が基本だ。TypeScript でコードを書く場合は、昔は TSLint というのを使っていたが、最近統合されて、TypeScript のルールも ESLint で扱えるようになったので覚えておこう。調べていく中で TSLint が出てきたら無視で OK だ。

1 つ 1 つルールを覚えていく必要はない。ESLint は何なのかを実際に動かして確かめ、どういう風に ESLint を設定するのか覚えることと、ルールの追加はどうすればできるのかを学ぶことが重要だ。

### 最低ライン

- まずは動かしてみる
  - eslint の設定ファイルを作る
  - セミコロンとかクォーテーションのルールを追加する
  - わざとそのルールに沿っていない JS ファイルを書く
  - `eslint [そのJSファイル]` を試してみる
  - おそらくエラー文が出るのでこんな感じで指摘してくれるのか、と知る
  - `eslint --fix [そのJSファイル]` で自動整形してくれるのも実感する
  - .eslintignore で特定のファイルを無視できることも試してみる
- VSCode 上で実感する
  - [VSCode の拡張機能](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)を入れる
  - VSCode 上で間違った構文を書くと指摘してくれることを知る
  - VSCode で保存をしたときに自動整形してくれるように VSCode の設定をいじる
    - 具体的には settings.json で、下記のような記述でいけるはず
      ```json
      "editor.codeActionsOnSave": {
        "source.fixAll.eslint": true
      },
      ```
  - もし今後 VSCode 上で ESLing が動かなくなったら VSCode の設定も疑ってみよう
- 設定項目を知る
  - 最初は理解できない項目だらけだと思うが、そこは理解できないまま進んでも問題ない。私もフワッとした理解のまま進めているところある。
  - ここだけは大事だというのが rules と extends と plugins
  - rules で色んな設定をできるが、ルールが数百種類あって、1 つ 1 つ設定していたら大変
  - そこで extends を使う。extends で既にあるルールを一気に適用でき、rules が膨らまなくてすむ
    - extends には ESLint が最初から入ってるものがあり、それが eslint:recommended だ。それを入れるだけで、[こちらのルール](https://github.com/eslint/eslint/blob/master/conf/eslint-recommended.js)が追加される。
    - extends で自動追加されたものは、自分で rules を追加して上書きもできる
    - plugins はそもそもの rules を追加できるもの。extends は最初からあるルールを一気に適用させるもの。
      - 例えば [eslint-plugin-react-hooks](https://www.npmjs.com/package/eslint-plugin-react-hooks) を使いたい場合、plugins に react-hooks を指定することにより、rules で react-hooks の指定ができるようになる
    - extends と plugins の落とし穴
      - plugins で指定しなくても plugins の rules を有効にすることができるものもある
      - plugins によっては extends で指定して自分で rules を書かなくとも有効にできるものもある
      - ここはややこしいので最初の段階で覚える必要がないが、私が最初に「？？」ってなったところなので書いた。

## Prettier

### 概要

Prettier はコードフォーマッター。ESLint と被って非常にややこしいが、Prettier はコードを整形することに特化している。ESLint は主に「フォーマットに関するルール」「コードの品質に関するルール」を扱うが、Prettier が扱うのは前者のフォーマットに関することのみ。後者には触れない。

ESLint で良くない？と思われるかもしれないが、ESLint だけでは整形できない部分もある。ESLint がカバーできない部分を Prettier が担うという形だ。ちなみに Prettier は JavaScript に限らず、Java, PHP, Ruby とかも対応している。

ESLint ほど多くはないが、Prettier も設定でお好みにカスタマイズできる。こちらも概要を掴み、自分で設定をして使えるようになろう。

### 最低ライン

- まずは動かしてみる
  - [公式の Playground](https://prettier.io/playground/)を使うのが早い
    - 左側で文を書いたら右側に Prettier 後のコードが表示される
    - これを VSCode で保存時に走らせられれば OK
- VSCode 上で実感する
  - [VSCode の拡張機能](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode)を入れる
  - VSCode で保存をしたときに自動整形してくれるように VSCode の設定をいじる
    - 具体的には settings.json で、下記のような記述でいけるはず
      ```json
        "editor.formatOnSave": true,
        "editor.defaultFormatter": "esbenp.prettier-vscode",
      ```
    - 保存時に format をする設定と、デフォルトのフォーマッターを Prettier にする設定だ
    - これで VSCode 上で Prettier に沿っていない書き方をして保存したら自動で整形されるはず
- 設定しよう
  - Prettier も設定を変更できる
    - 例えばクォーテーションのデフォルトはダブルだが、シングルにもできる
    - .prettierrc で行ったり、package.json で行ったり色々と設定方法があるので、お好きな方を使う。
  - 特定のファイルを無視することもできる
    - .prettierignore を作って実際に無視されるか試してみよう
- ESLint とあわせて動かそう

  - Prettier とかぶる設定項目を ESLint から削除しよう
    - 例えばクォーテーションの設定項目が被る。そういったものを一括で削除する [eslint-config-prettier](https://github.com/prettier/eslint-config-prettier) というものがあるので使う。
    - eslint-config-prettier をインストールし、extends に prettier を追加する
  - というような感じで ESLint と Prettier の設定はややこしかったりする

    - 全部覚える必要はないが、こちらも私が最初に躓いたところなので載せておく
    - ちなみにここ 1 年で大きく設定方法が変わっているので、数ヶ月に一度、自分の設定方法が正しいか確かめることをオススメする
    - このロードマップも適宜更新するが、常に最新とは限らないので注意。

    #### 仮想 DOM

React の理解にはまずは仮想 DOM の概念を理解することが大事。今まで JavaScript で実際の DOM を操作（append, querySelector など）してきたが、その DOM と仮想 DOM は違う（区別をするために今まで触っていた DOM を「リアル DOM」と名付ける）。リアル DOM は実際にあるものだが、仮想 DOM は実際にあるものではなくあくまで考え方の話。ちなみに言葉が似ている ShadowDOM はまた別の話なので混同しないように注意。仮想 DOM は英語では Virtual DOM 。

仮想 DOM は、まずはリアル DOM と同じようなものを JavaScript で再現し、後でリアル DOM へと変換される。何かしらイベントなどで DOM に変更があった場合、リアル DOM の場合は全体を再構築し直すのでレンダリングコストが高くなるが、仮想 DOM の場合は変更点だけを再構築するのでレンダリングコストが低い。具体的には差分検出といった仕組みがあるのだが、文面だけで最初に理解してもらうには相当難しいので一旦控える。とりあえず仮想 DOM はリアル DOM と比べてパフォーマンスが落ちにくいことを覚えて欲しい。

**仮想 DOM の世界ではリアル DOM の操作をしてはいけない。** つまり今まで JavaScript で当たり前に行っていた DOM 操作（append, querySelector など）は混合させないように注意が必要だ。せっかく仮想 DOM の世界で良いように動かしていたのに、そこにリアル DOM がくるとすべてが崩れる。酢豚にパインを混ぜるようなものだ。酢豚で完成されているのだからパインを混ぜて台無しにするようなことは絶対に控えて欲しい。

React だけでなく Vue, Angular なども仮想 DOM の概念を用いて作られている。
